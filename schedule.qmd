---
title: "Project Planner"
format:
  html:
    code-fold: true
    code-summary: "Show code"
    toc: true
    mainfont: "Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif"
    fontsize: "16px"
    css: custom.css
jupyter: python3
---

## New Year, new planning tool

As a productivity geek, I've used all kinds of planning tools. MS Project, spreadsheets, asana, etc, etc... After trying pretty much everything, I've always ended up facing the same problem. For planning personal research projects, these tools just take too much work to maintain compared to the value they provide. They are just not built for the kind of work that I, and I think most researchers do.

I'm not asking for much. I have a very simple use case. I have 5-10 research projects going on at any point in time, each has an end date and each has some budget (i.e., my time) on them left.

I want to be able to quickly answer a few questions:

1. What should I focus on this week, from a budget perspective?
2. Do I have too much or too little work?
3. When should I start a new project?
4. And when will I finally get to that back-burner project?

My frustration with existing tools and everything I tried is it is surprisingly difficult to answer those questions. I've tried vibe-coding a web planner that would help me answer those questions, but it became too complicated. Then I tried just using a spreadsheet, but the issue is that this is a sequential planning problem and that gets easily ugly in excel. So yet again I tried, and with Claude Code's help, I actually have something I like now.

## What This Tool Does

This planner answers those questions by scheduling your work over the next several months under two different scheduling strategies: Spreading work evenly across projects proportionally to their budget (paced), or knocking them out one by one (frontload).

## Data

The planner reads from a simple JSON file listing your projects, their deadlines, and how much work remains. That's it.

Each project needs an end date and an estimate of remaining days. Optionally, you can say that some projects will get "renewed". This is useful for grants that get renewed and goes for at least another year with a set budget.

The json file looks like this:

```json
{
  "projects": [
    {
      "name": "Project A",
      "end_date": "2026-03-30",
      "remaining_days": 28,
      "renewal_days": 10
    },
    {
      "name": "Project B",
      "end_date": "2026-08-31",
      "remaining_days": 23
    },
    ...
  ]
}
```

## Running the Scheduler:

Once you have your input data, you read it in, and create a schedule based on the data, choosing one of the methods.

The paced approach spreads work across all active projects, making steady progress on everything simultaneously. This is usually how researchers do their work. It prioritizes projects by deadline (earliest due date first) but tries to make sure every project gets worked on every two weeks.

The frontload approach completes projects one at a time in deadline order. The point of this method is to just provide a bounding case, and gives a better sense of priority, and when exactly I'd need more work if I was trying to knock everything out as soon as possible.

Both approaches assign a full day of work for each project - which I'm happy to do as a simplifying assumption.

Let's run both approaches and compare them:

```{python}
#| echo: true
#| message: false
#| warning: true

from datetime import date
import pandas as pd

# Import planner modules
from planner.scheduler import Scheduler
from planner.analysis import (
    load_projects,
    compute_weekly_availability,
    compute_monthly_unassigned_days,
    create_calendar_heatmap,
    create_availability_plot,
)

# Configuration
CONFIG_FILE = "projects.json"
NUM_WEEKS = 52

# Set date to when data was updated
start_date = date(2026, 2, 9)

# Load and schedule
projects = load_projects(CONFIG_FILE)
scheduler_paced = Scheduler(projects, start_date=start_date)
schedule_paced = scheduler_paced.create_schedule(num_weeks=NUM_WEEKS, method="paced")

scheduler_frontload = Scheduler(projects, start_date=start_date)
schedule_frontload = scheduler_frontload.create_schedule(num_weeks=NUM_WEEKS, method="frontload")

# Get statistics
stats_paced = scheduler_paced.get_statistics(schedule_paced)
stats_frontload = scheduler_frontload.get_statistics(schedule_frontload)

# Compute availability
paced_availability = compute_weekly_availability(schedule_paced, NUM_WEEKS)
frontload_availability = compute_weekly_availability(schedule_frontload, NUM_WEEKS)
```

```{python}
#| echo: false
#| warning: true

import warnings

def validate_budget_exhaustion(schedule, projects, label: str) -> pd.DataFrame:
    rows = []
    for project in projects:
        budget_days = project.slots_remaining
        if budget_days <= 0:
            continue

        assigned_dates = sorted([s.date for s in schedule.slots if s.project == project])
        days_scheduled = len(assigned_dates)

        exhausted_on = None
        if days_scheduled >= budget_days:
            exhausted_on = assigned_dates[budget_days - 1]

        days_before_deadline = None
        if exhausted_on is not None:
            days_before_deadline = (project.end_date - exhausted_on).days

        if (
            schedule.end_date is not None
            and project.end_date <= schedule.end_date
            and days_scheduled < budget_days
        ):
            warnings.warn(
                f"[{label}] Project '{project.name}' ended on {project.end_date} "
                f"with {budget_days - days_scheduled} day(s) of budget remaining "
                f"({days_scheduled}/{budget_days} scheduled).",
                category=UserWarning,
                stacklevel=2,
            )

        rows.append(
            {
                "project": project.name,
                "end_date": project.end_date,
                "budget_days": budget_days,
                "days_scheduled": days_scheduled,
                "exhausted_on": exhausted_on,
                "days_before_deadline": days_before_deadline,
            }
        )

    df = pd.DataFrame(rows).sort_values(["end_date", "project"])

    total_budget_days = int(df["budget_days"].sum()) if not df.empty else 0
    all_assigned_dates = sorted([s.date for s in schedule.slots if s.project is not None])
    all_budget_exhausted_on = (
        all_assigned_dates[total_budget_days - 1]
        if total_budget_days > 0 and len(all_assigned_dates) >= total_budget_days
        else None
    )

    if total_budget_days > 0 and all_budget_exhausted_on is None:
        warnings.warn(
            f"[{label}] Total budget across projects ({total_budget_days} day(s)) "
            f"was not fully scheduled within the horizon.",
            category=UserWarning,
            stacklevel=2,
        )

    print(
        f"[{label}] Total budget days: {total_budget_days}; "
        f"total scheduled days: {len(all_assigned_dates)}; "
        f"all budget exhausted on: {all_budget_exhausted_on}"
    )

    return df

budget_paced = validate_budget_exhaustion(schedule_paced, scheduler_paced.projects, "paced")
budget_frontload = validate_budget_exhaustion(schedule_frontload, scheduler_frontload.projects, "frontload")

display(
    budget_paced[
        [
            "project",
            "end_date",
            "budget_days",
            "days_scheduled",
            "exhausted_on",
            "days_before_deadline",
        ]
    ].rename(
        columns={
            "project": "Project",
            "end_date": "End Date",
            "budget_days": "Budget Days",
            "days_scheduled": "Days Scheduled",
            "exhausted_on": "Budget Exhausted On",
            "days_before_deadline": "Days Before Deadline",
        }
    )
)

display(
    budget_frontload[
        [
            "project",
            "end_date",
            "budget_days",
            "days_scheduled",
            "exhausted_on",
            "days_before_deadline",
        ]
    ].rename(
        columns={
            "project": "Project",
            "end_date": "End Date",
            "budget_days": "Budget Days",
            "days_scheduled": "Days Scheduled",
            "exhausted_on": "Budget Exhausted On",
            "days_before_deadline": "Days Before Deadline",
        }
    )
)
```


# Paced Schedule

The paced schedule looks pretty realistic to me, and makes sense. I iterated a bit to get it to work the way I wanted.

Briefly, the paced scheduler uses a simple pacing “credit” model: each active project accrues fractional credit every working day at a constant rate chosen so that (if capacity allows) it burns down its remaining days close to its end date, not months early. We only schedule projects that have accumulated enough credit (i.e., they’re “due” for work), and we also apply deadline-feasibility guards so that projects that would otherwise miss their end date get forced to run as needed. Weekends are skipped, and days can remain unassigned if no project is currently due.

For my projects, it works out this way:

```{python}
#| label: fig-paced-calendar
#| fig-cap: "Paced scheduling: balanced progress across all projects"
#| column: page

fig_paced_cal = create_calendar_heatmap(schedule_paced, "Paced Method Calendar")
if fig_paced_cal:
    fig_paced_cal.show()
```

```{python}
#| echo: false
#| label: tbl-paced-unassigned
#| tbl-cap: "Unassigned days per month (Paced Method)"

unassigned_paced = compute_monthly_unassigned_days(schedule_paced, include_zero_months=True)
unassigned_paced["cumulative_unassigned_days"] = unassigned_paced["unassigned_days"].cumsum()
if not unassigned_paced.empty:
    display(unassigned_paced[['month_name', 'unassigned_days', 'cumulative_unassigned_days']].rename(
        columns={'month_name': 'Month', 'unassigned_days': 'Unassigned Days', 'cumulative_unassigned_days': 'Cumulative Unassigned Days'}
    ))
```

This is quite realistic and useful.

This schedule pushes one of the projects I was working on to April. Interestingly, before running this, I was hoping I was going to be able to work on that sooner, but apparently not. Either way, that's useful information.

### Frontloaded Schedule

The Frontloaded schedule looks as you'd expect.

```{python}
#| label: fig-frontload-calendar
#| fig-cap: "Frontload scheduling: complete projects sequentially"
#| column: page

fig_frontload_cal = create_calendar_heatmap(schedule_frontload, "Frontload Method Calendar")
if fig_frontload_cal:
    fig_frontload_cal.show()
```

```{python}
#| echo: false
#| label: tbl-frontload-unassigned
#| tbl-cap: "Unassigned days per month (Frontload Method)"

unassigned_frontload = compute_monthly_unassigned_days(schedule_frontload, include_zero_months=True)
unassigned_frontload["cumulative_unassigned_days"] = unassigned_frontload["unassigned_days"].cumsum()
if not unassigned_frontload.empty:
    display(unassigned_frontload[['month_name', 'unassigned_days', 'cumulative_unassigned_days']].rename(
        columns={'month_name': 'Month', 'unassigned_days': 'Unassigned Days', 'cumulative_unassigned_days': 'Cumulative Unassigned Days'}
    ))
```

## When should I start a new project?

I can already look at the paced schedule and see that I will have about a day or two of availability per week only in July. But to see that more clearly, let's see that in a plot.


```{python}
#| label: fig-availability
#| fig-cap: "Weekly availability: how much capacity remains each week"
#| column: page

fig = create_availability_plot(paced_availability, frontload_availability)
fig.show()
```

## Final thoughts.

Okay, so after doing this, I'm feeling pretty good about this year. I have quite a bit ahead of me until July, so I should start planning for that. Looking at the questions I wanted to answer, I think I got answers:

1. What should I focus on this week, from a budget perspective? *the paced schedule answers this*
2. Do I have too much or too little work? *I have quite a bit already*
3. When should I start a new project? *Looks like I can't do anything new until June/July*
4. And when will I finally get to that back-burner project? *Looks like it's in April.*

## How to use this:

You will need a little familiarity with python to use this. Let me know if this seems useful. I'd hope project management tools would implement something like this. Clone my repo, `uv sync` and run it.
