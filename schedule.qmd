---
title: "Project Planner"
format:
  html:
    code-fold: true
    code-summary: "Show code"
    toc: true
    mainfont: "Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif"
    fontsize: "16px"
    css: custom.css
jupyter: python3
---

## New Year, new planning tool

As a productivity geek, I've used all kinds of planning tools. MS Project, spreadsheets, asana, etc, etc... After trying pretty much everything, I've always ended facing the same problem. For planning personal research projects, these tools just take too much work to maintain compared to the value they provide. They are just not built for the kind of work that I, and I think most researchers do.

I'm not asking for much. I have a very simple use case. I have 5-10 research projects going on at any point in time, each has an end date and each has some budget (i.e., my time) on them left.

I want to be able to quickly answer a few questions:

1. What should I focus on this week, from a budget perspective?
2. Do I have too muchor too little work? 
3. When should I start a new project? 
4. And when will I finally get to that back-burner project?

My frustration with existing tools and everything I tried is it is surprisingly difficult to answer those questions. I've tried vibe-coding a web planner that would help me answer those questions, but it became too complicated. Then I tried just using a spreadsheet, but the issue is that this is a sequential planning problem and that gets easily ugly in excel. So yet again I tried, and with CLaude codes help, I actually have something I like now.

## What This Tool Does

This planner answers those questions by scheduling your work over the next several months under two different scheduling strategies: Spreading work evenly across projects proportionally to their budget (paced), or knocking them out one by one (frontload).

## Data

The planner reads from a simple JSON file listing your projects, their deadlines, and how much work remains. That's it.

Each project needs an end date and an estimate of remaining days. Optionally, you can say that some projects will get "renewed". This is useful for grants that get renewed and goes for at least another year with a set budget.

The json file looks like this:

```json
{
  "projects": [
    {
      "name": "Project A",
      "end_date": "2026-03-30",
      "remaining_days": 28,
      "renewal_days": 10
    },
    {
      "name": "Project B",
      "end_date": "2026-08-31",
      "remaining_days": 23
    },
    ...
  ]
}
```

## Running the Scheduler:

Once you have your input data, you read it in, and create a schedule based on the data, choosing one of the methods.

The paced approach spreads work across all active projects, making steady progress on everything simultaneously. This is usually how researchers do their work. It prioritizes projects by deadline (earliest due date first) but tries to make sure all project gets worked on every two weeks. 

The frontload approach completes projects one at a time in deadline order. The point of this method is to just provide a bounding case, and gives a better sence of priority, and when exactly I'd need more work if I was trying to knock everything out as soon as possible. Let's run both approaches and compare them:

```{python}
#| echo: true
#| message: false
#| warning: false

from datetime import date
import pandas as pd

# Import planner modules
from planner.scheduler import Scheduler
from planner.analysis import (
    load_projects,
    compute_weekly_availability,
    create_calendar_heatmap,
    create_availability_plot,
)

# Configuration
CONFIG_FILE = "projects.json"
NUM_WEEKS = 52

# Load and schedule
projects = load_projects(CONFIG_FILE)
scheduler = Scheduler(projects, start_date=date.today())
schedule_paced = scheduler.create_schedule(num_weeks=NUM_WEEKS, method="paced")
schedule_frontload = scheduler.create_schedule(num_weeks=NUM_WEEKS, method="frontload")

# Get statistics
stats_paced = scheduler.get_statistics(schedule_paced)
stats_frontload = scheduler.get_statistics(schedule_frontload)

# Compute availability
paced_availability = compute_weekly_availability(schedule_paced, NUM_WEEKS)
frontload_availability = compute_weekly_availability(schedule_frontload, NUM_WEEKS)
```


# Paced Schedule

The paced schedule looks pretty realistic to me, and makes quite bit of sense. I iterated a bit to get it to work this way.



```{python}
#| label: fig-paced-calendar
#| fig-cap: "Paced scheduling: balanced progress across all projects"
#| column: page

fig_paced_cal = create_calendar_heatmap(schedule_paced, "Paced Method Calendar")
if fig_paced_cal:
    fig_paced_cal.show()
```

### Frontloaded Schedule

The Frontloaded schedule looks as you'd expect.

```{python}
#| label: fig-frontload-calendar
#| fig-cap: "Frontload scheduling: complete projects sequentially"
#| column: page

fig_frontload_cal = create_calendar_heatmap(schedule_frontload, "Frontload Method Calendar")
if fig_frontload_cal:
    fig_frontload_cal.show()
```


## When should I start new projects?

Plott

The availability chart answers this directly. If you see weeks at 0% availability stretching far into the future, you're overcommitted. If you see 50%+ availability throughout, you can comfortably take on more.

The difference between the two methods shows you the cost of context switching. Paced scheduling typically shows lower availability because it maintains multiple active projects simultaneously.

```{python}
#| label: fig-availability
#| fig-cap: "Weekly availability: how much capacity remains each week"
#| column: page

fig = create_availability_plot(paced_availability, frontload_availability)
fig.show()
```

```{python}
#| echo: false

# Calculate insights
paced_percents = [w['percent_available'] for w in paced_availability]
frontload_percents = [w['percent_available'] for w in frontload_availability]

paced_avg = sum(paced_percents) / len(paced_percents) if paced_percents else 0
frontload_avg = sum(frontload_percents) / len(frontload_percents) if frontload_percents else 0

print(f"**Paced Method:** Average availability = {paced_avg:.1f}%")
print(f"**Frontload Method:** Average availability = {frontload_avg:.1f}%")
```

Look at the next 4-8 weeks to see when you can realistically start new work. If both methods show you're fully booked through that period, you'll need to defer new commitments or renegotiate existing deadlines.
