---
title: "Project Planner"
format:
  html:
    code-fold: true
    code-summary: "Show code"
    toc: true
    mainfont: "Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif"
    fontsize: "16px"
    css: custom.css
jupyter: python3
---

## New Year, new planning tool

As a productivity geek, I've used all kinds of planning tools. MS Project, spreadsheets, asana, etc, etc... After trying pretty much everything, I've always ended up facing the same problem. For planning personal research projects, these tools just take too much work to maintain compared to the value they provide. They are just not built for the kind of work that I, and I think most researchers do.

I'm not asking for much. I have a very simple use case. I have 5-10 research projects going on at any point in time, each has an end date and each has some budget (i.e., my time) on them left.

I want to be able to quickly answer a few questions:

1. What should I focus on this week, from a budget perspective?
2. Do I have too much or too little work? 
3. When should I start a new project? 
4. And when will I finally get to that back-burner project?

My frustration with existing tools and everything I tried is it is surprisingly difficult to answer those questions. I've tried vibe-coding a web planner that would help me answer those questions, but it became too complicated. Then I tried just using a spreadsheet, but the issue is that this is a sequential planning problem and that gets easily ugly in excel. So yet again I tried, and with Claude Code's help, I actually have something I like now.

## What This Tool Does

This planner answers those questions by scheduling your work over the next several months under two different scheduling strategies: Spreading work evenly across projects proportionally to their budget (paced), or knocking them out one by one (frontload).

## Data

The planner reads from a simple JSON file listing your projects, their deadlines, and how much work remains. That's it.

Each project needs an end date and an estimate of remaining days. Optionally, you can say that some projects will get "renewed". This is useful for grants that get renewed and goes for at least another year with a set budget.

The json file looks like this:

```json
{
  "projects": [
    {
      "name": "Project A",
      "end_date": "2026-03-30",
      "remaining_days": 28,
      "renewal_days": 10
    },
    {
      "name": "Project B",
      "end_date": "2026-08-31",
      "remaining_days": 23
    },
    ...
  ]
}
```

## Running the Scheduler:

Once you have your input data, you read it in, and create a schedule based on the data, choosing one of the methods.

The paced approach spreads work across all active projects, making steady progress on everything simultaneously. This is usually how researchers do their work. It prioritizes projects by deadline (earliest due date first) but tries to make sure every project gets worked on every two weeks. 

The frontload approach completes projects one at a time in deadline order. The point of this method is to just provide a bounding case, and gives a better sense of priority, and when exactly I'd need more work if I was trying to knock everything out as soon as possible.

Both approaches assign a full day of work for each project - which I'm happy to do as a simplifying assumption.

Let's run both approaches and compare them:

```{python}
#| echo: true
#| message: false
#| warning: false

from datetime import date
import pandas as pd

# Import planner modules
from planner.scheduler import Scheduler
from planner.analysis import (
    load_projects,
    compute_weekly_availability,
    compute_monthly_unassigned_days,
    create_calendar_heatmap,
    create_availability_plot,
)

# Configuration
CONFIG_FILE = "projects.json"
NUM_WEEKS = 52

# Load and schedule
projects = load_projects(CONFIG_FILE)
scheduler = Scheduler(projects, start_date=date.today())
schedule_paced = scheduler.create_schedule(num_weeks=NUM_WEEKS, method="paced")
schedule_frontload = scheduler.create_schedule(num_weeks=NUM_WEEKS, method="frontload")

# Get statistics
stats_paced = scheduler.get_statistics(schedule_paced)
stats_frontload = scheduler.get_statistics(schedule_frontload)

# Compute availability
paced_availability = compute_weekly_availability(schedule_paced, NUM_WEEKS)
frontload_availability = compute_weekly_availability(schedule_frontload, NUM_WEEKS)
```


# Paced Schedule

The paced schedule looks pretty realistic to me, and makes sense. I iterated a bit to get it to work the way I wanted.

Briefly, this scheduling algorithm builds a schedule by assigning days to projects based on a target "ideal days per week" computed from each project's remaining work divided by time until its deadline. Each project has a weekly cap set to the floor of that ideal, with fractional leftovers accumulating - this effectively assigns a day to a project only when I can actually work a full day on it. Fair. Among projects still under their weekly cap, we prioritize projects with earlier deadlines. Weekly tallies reset every Monday, weekends are skipped, and days can remain unassigned if no project is eligible.

For my projects, it works out this way:

```{python}
#| label: fig-paced-calendar
#| fig-cap: "Paced scheduling: balanced progress across all projects"
#| column: page

fig_paced_cal = create_calendar_heatmap(schedule_paced, "Paced Method Calendar")
if fig_paced_cal:
    fig_paced_cal.show()
```

```{python}
#| echo: false
#| label: tbl-paced-unassigned
#| tbl-cap: "Unassigned days per month (Paced Method)"

unassigned_paced = compute_monthly_unassigned_days(schedule_paced)
if not unassigned_paced.empty:
    display(unassigned_paced[['month_name', 'unassigned_days']].rename(
        columns={'month_name': 'Month', 'unassigned_days': 'Unassigned Days'}
    ))
```

This is quite realistic and useful.

This schedule pushes one of the projects I was working on to April. Interestingly, before running this, I was hoping I was going to be able to work on that sooner, but apparently not. Either way, that's useful information.

### Frontloaded Schedule

The Frontloaded schedule looks as you'd expect.

```{python}
#| label: fig-frontload-calendar
#| fig-cap: "Frontload scheduling: complete projects sequentially"
#| column: page

fig_frontload_cal = create_calendar_heatmap(schedule_frontload, "Frontload Method Calendar")
if fig_frontload_cal:
    fig_frontload_cal.show()
```

```{python}
#| echo: false
#| label: tbl-frontload-unassigned
#| tbl-cap: "Unassigned days per month (Frontload Method)"

unassigned_frontload = compute_monthly_unassigned_days(schedule_frontload)
if not unassigned_frontload.empty:
    display(unassigned_frontload[['month_name', 'unassigned_days']].rename(
        columns={'month_name': 'Month', 'unassigned_days': 'Unassigned Days'}
    ))
```

## When should I start a new project?

I can already look at the paced schedule and see that I will have about a day or two of availability per week only in July. But to see that more clearly, let's see that in a plot.


```{python}
#| label: fig-availability
#| fig-cap: "Weekly availability: how much capacity remains each week"
#| column: page

fig = create_availability_plot(paced_availability, frontload_availability)
fig.show()
```

## Final thoughts.

Okay, so after doing this, I'm feeling pretty good about this year. I have quite a bit ahead of me until July, so I should start planning for that. Looking at the questions I wanted to answer, I think I got answers:

1. What should I focus on this week, from a budget perspective? *the paced schedule answers this*
2. Do I have too much or too little work? *I have quite a bit already*
3. When should I start a new project? *Looks like I can't do anything new until June/July*
4. And when will I finally get to that back-burner project? *Looks like it's in April.*

## How to use this:

You will need a little familiarity with python to use this. Let me know if this seems useful. I'd hope project management tools would implement something like this. Clone my repo, `uv sync` and run it.